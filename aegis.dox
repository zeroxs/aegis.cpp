 
 
/*! \mainpage aegis.cpp documentation
 
\section intro_sec Introduction
 
 
These docs are being worked on. Some quick examples and brief explanations in the mean time.
 
 
# Example usage #
 
The most minimal usage example:
 
~~~~~~~~~~~~~~~{.cpp}
#include <aegis.hpp>

using json = nlohmann::json;

int main(int argc, char * argv[])
{
    try
    {
        // Create bot object with a minimum log level of trace
        aegis::core bot(spdlog::level::trace);

		bot.log->trace("Bot object created");

		// With min log level set to tracce and wsdbg (websocket debug) set to true
		// the bot will dump all websocket messages to console
		bot.wsdbg = true;
 
        // These callbacks are what are called when websocket events occur
        aegis::callbacks cbs;
        cbs.i_message_create = [&](aegis::gateway::events::message_create obj)
        {
		    std::string content{ obj.msg.get_content() };
            
			auto & _channel = obj.msg.get_channel();

            // Simple Hi response
            if (content == "~Hi")
            {
                _channel.create_message("Hello back");
            }
			else if (content == "~React")
			{
				// use an emoji your bot has access to here
				auto response = obj.msg.create_reaction("success:429554838083207169").get();
                if (response)
                {
                    // reaction was a success. maybe chain another?
                    auto response = obj.msg.create_reaction("fail:429554869611921408");

                    // perhaps you'd like to leverage asio to respond
                    bot.async([&_channel, fut = std::move(response)]() mutable
                    {
                        auto response = fut.get();
                        if (response)
                            _channel.create_message("React complete");
                        else
                            _channel.create_message("React failed");
                    });
                }
			}
		}

		// Assign callbacks
        bot._callbacks = cbs;

        // start the bot with 3 async threads. the function passed is executed after
		// the internal logger is set up and the websocket gateway information is collected.
        bot.run(3, [&]
        {
            bot.log->info("Gateway says we need to use {} shards", bot.shard_max_count);
        });
    }
    catch (std::exception & e)
    {
        std::cout << "Error during initialization: " << e.what() << '\n';
        return 1;
    }
    std::cout << "Press any key to continue...\n";
    std::cin.ignore();
    return 0;
}
~~~~~~~~~~~~~~~
 
 
 
 
 
 
*/
 
 